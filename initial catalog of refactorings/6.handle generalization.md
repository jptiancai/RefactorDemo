## Pull Up Field（值域上移） ##

- 动机（Motivation）


判断若干值域是否重复，惟一的办法就是观察函数如何使用它们。如果它们被使用的方式很相似，你就可以将它们归纳到superclass 去。

 

本项重构从两方面减少重复：首先它去除了「重复的数据声明」；其次它使你可以将使用该值域的行为从subclass 移至superclass，从而去除「重复的行为」。


## Pull Up Method（函数上移）##

- 动机（Motivation）

如果某个函数在各subclass 中的函数体都相同（它们很可能是通过「拷贝-粘贴」得到的），这就是最显而易见的Pull Up Method 适用场合。当然，情况并不总是如此明显。你也可以只管放心地重构，再看看测试程序会不会发牢骚，但这就需要对你的测试有充分的信心。我发现，观察这些可疑（可能重复的〕函数之间的差异往往大有收获：它们经常会向我展示那些我忘记测试的行为。

 

Pull Up Method 常常紧随其他重构而被使用。也许你能找出若干个「身处不 同subclasses 内的函数」而它们又可以「通过某种形式的参数调整」而后成为相同函数。这时候，最简单的办法就是首先分别调整这些函数的参数，然后再将它们概括（generalize）到superclass中。当然，如果你自信足够，也可以一次同时完成这两个步骤。

```
// 两个subclass 都有一个createBill() 函数，并且代码完全一样：

 void createBill (date Date) {
   double chargeAmount = charge (lastBillDate, date);
   addBill (date, charge);
 }

```
重构后的代码：
```
//但我不能直接把这个函数上移到superclass
//因为各个subclass 的chargeFor() 函数并不相同。
//我必须先在superclass 中声明chargeFor()  抽象函数：

 

 class Customer...

   abstract double chargeFor(date start, date end)

```

## Pull Up Constructor Body（构造函数本体上移）##

- 动机（Motivation）

如果你看见各个subclass 中的函数有共同行为，你的第一个念头应该是将共同行为提炼到一个独立函数中，然后将这个函数提升到superclass 。对构造函数而言，它们彼此的共同行为往往就是「对象的建构」。这时候你需要在superclass 中提供一个构造函数，然后让subclass 都来调用它。很多时候，「调用superclass 构造函数」就是subclass 构造函数的惟一动作。这里不能运用Pull Up Method，因为你无法在subclass 中继承superclass 构造函数（你可曾痛恨过这个规定？）。

```
 

 class Employee...
   protected String _name;
   protected String _id;
 
 class Manager extends Employee...

   public Manager (String name, String id, int grade) {
       _name = name;
       _id = id;
       _grade = grade;
   }

   private int _grade;
```

```
 class Employee

   protected Employee (String name, String id) {
       _name = name;
       _id = id;
   }

    public Manager (String name, String id, int grade) {
       super (name, id);
       _grade = grade;
   }
```

- 后来情况又有些变化，构造函数中出现了共同代码 assignCar()
```
 class Employee...

   boolean isPriviliged() {..}
   void assignCar() {..}
 class Manager...

   public Manager (String name, String id, int grade) {
       super (name, id);
       _grade = grade;
       if (isPriviliged()) assignCar(); //every subclass does this
   }

   boolean isPriviliged() {
       return _grade > 4;
   }
```

移到superClass中
```
 class Employee...

   void initialize() {
       if (isPriviliged()) assignCar();
   }
   
 class Manager...

   public Manager (String name, String id, int grade) {
       super (name, id);
       _grade = grade;
       initialize();
   }
```