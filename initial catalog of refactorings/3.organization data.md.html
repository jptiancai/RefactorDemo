<!doctype html public '-//W3C//DTD HTML 4.0 Transitional //EN'>
<html>
<head>
<title>3.organization data</title>
<meta charset='UTF-8' />
<meta name='generator' content='EverEdit' />
<link href='E:\EverEdit\mode\markdown\default.css' rel='stylesheet'></link>
<link href='E:\EverEdit\mode\markdown\prettify.css' rel='stylesheet'></link>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\prettify.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\jquery-1.10.2.min.js'></script>
<script type='text/javascript' src='E:\EverEdit\mode\markdown\toc.js'></script>
</head>
<body>
<div id='generated-toc'></div>
<h2>Self Encapsulate Field（自封装值域）</h2>

<p>如果你想访问superclass中的一个值域，却又想在subclass中将「对这个变量的访问」改为一个计算后的值，这就是最该使用Self Encapsulate Field的时候。「值域自我封装」只是第一步。完成自我封装之后，你可以在subclass中根据自己的需要随意覆写取值/设值函数（getting and setting methods ）。</p>

<pre><code> class IntRange {

   boolean includes (int arg) {
       return arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();
   }

   void grow(int factor) {
       setHigh (getHigh() * factor);
   }

   private int _low, _high;

   int getLow() {
       return _low;
   }

   int getHigh() {
       return _high;
   }

   void setLow(int arg) {
       _low = arg;
   }

   void setHigh(int arg) {
       _high = arg;
   }</code></pre>

<p>重构后的代码：</p>

<pre><code>   IntRange (int low, int high) {
       initialize (low, high);
   }

   private void initialize (int low, int high) {
       _low = low;
       _high = high;
   }

 //一旦你拥有一个subclass，上述所有动作的价值就体现出来了。如下所示：

  class CappedRange extends IntRange {

   CappedRange (int low, int high, int cap) {
       super (low, high);
       _cap = cap;
   }

   private int _cap;

   int getCap() {
       return _cap;
   }

   int getHigh() {
       return Math.min(super.getHigh(), getCap());
   }
  }
</code></pre>

<h2>Replace Data Value with Object（以对象取代数据值）</h2>

<pre><code>class Order...

   public Order (String customer) {
       _customer = customer;
   }

   public String getCustomer() {
       return _customer;
   }

   public void setCustomer(String arg) {
       _customer = arg;
   }
   private String _customer;

   private static int numberOfOrdersFor(Collection orders, String customer) {
       int result = 0;
       Iterator iter = orders.iterator();
       while (iter.hasNext()) {
           Order each = (Order) iter.next();
           if (each.getCustomerName().equals(customer)) result++;
       }
       return result;
   }

</code></pre>

<p>重构后的代码：新建Customer类</p>

<pre><code> class Customer {

   public Customer (String name) {
       _name = name;
   }

   public String getName() {
       return _name;
   }

   private final String _name;
  }


class Order...

   public Order (String customerName) {
       _customer = new Customer(customerName);
   }

   public String getCustomerName() {
       return _customer.getName();
   }

   private Customer _customer;

   public void setCustomer(String customerName) {
       _customer = new Customer(customerName);
   }
</code></pre>

<h2>Change Value to Reference（将实值对象改为引用对象）</h2>

<pre><code> class Customer {

   public Customer (String name) {
       _name = name;
   }

   public String getName() {
       return _name;
   }

   private final String _name;
  }


class Order...

   public Order (String customerName) {
       _customer = new Customer(customerName);
   }

   public String getCustomerName() {
       return _customer.getName();
   }

   private Customer _customer;

   public void setCustomer(String customerName) {
       _customer = new Customer(customerName);
   }

  private static int numberOfOrdersFor(Collection orders, String customer) {

      int result = 0;

      Iterator iter = orders.iterator();
      while (iter.hasNext()) {
          Order each = (Order) iter.next();
          if (each.getCustomerName().equals(customer)) result++;
      }
      return result;

  }


</code></pre>

<p>重构后的代码：引入factory method </p>

<pre><code> class Order {

 public Order (String customer) {
     _customer = Customer.create(customer);
 }

 class Customer {

private static Dictionary _instances = new Hashtable();

//在应用程序的启动代码（start-up code）中，
//我先把需要使用的Customer对象加载妥当。
//这些对象可能来自数据库，也可能来自文件
    static void loadCustomers() {
       new Customer ("Lemon Car Hire").store();
       new Customer ("Associated Coffee Machines").store();
       new Customer ("Bilston Gasworks").store();
   }

   private void store() {
       _instances.put(this.getName(), this);
   }

  public static Customer getNamed (String name) {
       return (Customer) _instances.get(name);
}

   private Customer (String name) {
      _name = name;
   }
</code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>

<h2>#</h2>

<pre><code>
</code></pre>

<p>重构后的代码：</p>

<pre><code></code></pre>
<script type='text/javascript'>
$(document).ready(function(){
  if($('code').length>0){
    $('code').parent().addClass('prettyprint linenums');
    prettyPrint();
};
});
</script>
</body>
</html>